{"version":3,"sources":["index.js","db.js","geo\\index.js","geo\\point.js","validate.js","constant.js","util.js","serverDate\\index.js","helper\\symbol.js","utils\\symbol.js","utils\\type.js","geo\\lineString.js","geo\\polygon.js","geo\\multiPoint.js","geo\\multiLineString.js","geo\\multiPolygon.js","collection.js","document.js","lib\\util.js","serializer\\update.js","commands\\update.js","operator-map.js","commands\\query.js","commands\\logic.js","serializer\\common.js","serializer\\datatype.js","query.js","serializer\\query.js","aggregate.js","command.js","regexp\\index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;ACFA,AJYA,ACHA,ACHA,ACHA;ACFA,AJYA,ACHA,ACHA,ACHA;ACFA,AJYA,ACHA,ACHA,ACHA;ACFA,AJYA,AENA,AGTA,AFMA;ACFA,AJYA,AENA,AGTA,AFMA;ACFA,AJYA,AENA,AGTA,AFMA;ACFA,AJYA,AENA,AIZA,ADGA,AFMA;ACFA,AJYA,AENA,AIZA,ADGA,AFMA;ACFA,AJYA,AENA,AIZA,ADGA,AFMA;ACFA,AJYA,AENA,AKfA,ADGA,ADGA,AFMA;ACFA,AJYA,AENA,AKfA,ADGA,ADGA,AFMA;ACFA,AJYA,AENA,AKfA,ADGA,ADGA,AFMA;ACFA,AJYA,AENA,AKfA,ADGA,ADGA,AGTA,ALeA;ACFA,AJYA,AENA,AKfA,ADGA,ADGA,AGTA,ALeA;ACFA,AJYA,AENA,AKfA,ADGA,ADGA,AGTA,ALeA;ACFA,AJYA,AENA,AKfA,ADGA,ADGA,AGTA,ACHA,ANkBA;ACFA,AJYA,AENA,AKfA,ADGA,ADGA,AGTA,ACHA,ANkBA;ACFA,AJYA,AENA,AKfA,ADGA,ADGA,AGTA,ACHA,ANkBA;ACFA,AJYA,AU9BA,ARwBA,AKfA,ADGA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,ARwBA,AKfA,ADGA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,ARwBA,AKfA,ADGA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,ARwBA,AS3BA,AJYA,ADGA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,ARwBA,AS3BA,AJYA,ADGA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,ARwBA,AS3BA,AJYA,ADGA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,AENA,AV8BA,AS3BA,AJYA,ADGA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,AENA,AV8BA,AS3BA,AJYA,ADGA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,AENA,AV8BA,AS3BA,AJYA,ADGA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,AGTA,ADGA,AV8BA,AS3BA,AJYA,ADGA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,AGTA,ADGA,AV8BA,AS3BA,AJYA,ADGA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,AGTA,ADGA,AV8BA,AS3BA,ALeA,ADGA,AGTA,ACHA,ANkBA;ACFA,AMlBA,AGTA,ADGA,AENA,AZoCA,AS3BA,ANkBA,AGTA,ACHA,ANkBA;ACFA,AMlBA,AGTA,ADGA,AENA,AZoCA,AS3BA,ANkBA,AGTA,ACHA,ANkBA;ACFA,AMlBA,AGTA,ADGA,AENA,AZoCA,AS3BA,ANkBA,AGTA,ACHA,ANkBA;AYnCA,AXiCA,AMlBA,AGTA,ADGA,AENA,AZoCA,AS3BA,ANkBA,AGTA,ACHA,ANkBA;AYnCA,AXiCA,AMlBA,AGTA,ADGA,AENA,AZoCA,AS3BA,ANkBA,AGTA,ACHA,ANkBA;AYnCA,AXiCA,AMlBA,AGTA,ADGA,AENA,AZoCA,AS3BA,ANkBA,AGTA,ACHA,ANkBA;AYnCA,AXiCA,AYpCA,ANkBA,AGTA,ADGA,AENA,AZoCA,AS3BA,ANkBA,AGTA,ACHA,ANkBA;AYnCA,AXiCA,AYpCA,ANkBA,AGTA,ADGA,AENA,AZoCA,AS3BA,ANkBA,AGTA,ACHA,ANkBA;AYnCA,AXiCA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,ANkBA,AGTA,ALeA;AYnCA,AXiCA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AZoCA,AGTA,ALeA;AYnCA,AXiCA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AZoCA,AGTA,ALeA;AYnCA,AXiCA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AZoCA,AGTA,ALeA;AYnCA,AXiCA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,ACHA,AbuCA,AGTA,ALeA;AYnCA,AXiCA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,ACHA,AbuCA,AGTA,ALeA;AYnCA,AXiCA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,ACHA,AbuCA,AGTA,ALeA;AYnCA,AIZA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,ACHA,AbuCA,AGTA,ALeA;AYnCA,AIZA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,ACHA,AbuCA,AGTA,ALeA;AYnCA,AIZA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,ACHA,AbuCA,AGTA,ALeA;AYnCA,AIZA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AGTA,AFMA,AbuCA,AGTA,ALeA;AYnCA,AIZA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AGTA,AFMA,AbuCA,AGTA,ALeA;AYnCA,AIZA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AGTA,AFMA,AbuCA,AGTA,ALeA;AYnCA,AMlBA,AFMA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AGTA,AFMA,AbuCA,AGTA,ALeA;AYnCA,AMlBA,AFMA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AGTA,AFMA,AbuCA,AFMA;AYnCA,AMlBA,AFMA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AGTA,AFMA,AbuCA,AFMA;AYnCA,AOrBA,ADGA,AFMA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AGTA,AFMA,AbuCA;AU7BA,AOrBA,ADGA,AFMA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AGTA,AFMA,AbuCA;AU7BA,AOrBA,ADGA,AFMA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AGTA,AFMA,AbuCA;AU7BA,AOrBA,ADGA,AFMA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AGTA,AGTA,ALeA,AbuCA;AiBlDA,ADGA,AFMA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AGTA,AGTA,ALeA,AbuCA;AiBlDA,ADGA,AFMA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AGTA,AGTA,ALeA,AbuCA;AiBlDA,ADGA,AFMA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AGTA,AGTA,ACHA,ANkBA,AbuCA;AiBlDA,ADGA,AFMA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AGTA,AGTA,ACHA,ANkBA,AbuCA;AiBlDA,ADGA,AFMA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AGTA,AGTA,ACHA,ANkBA,AbuCA;AiBlDA,ADGA,AFMA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AGTA,AKfA,AFMA,ACHA,ANkBA,AbuCA;AiBlDA,ADGA,AFMA,Af6CA,AYpCA,ANkBA,AGTA,ADGA,AENA,AHSA,AMlBA,AGTA,AKfA,AFMA,ACHA,ANkBA,AbuCA;AiBlDA,ADGA,AFMA,AHSA,ANkBA,AGTA,ADGA,AENA,AHSA,AS3BA,AKfA,AFMA,ACHA,ANkBA,AbuCA;AiBlDA,ADGA,AFMA,AHSA,ANkBA,AGTA,ADGA,AENA,AHSA,AS3BA,AKfA,AFMA,ACHA,AENA,ARwBA,AbuCA;AiBlDA,ADGA,AFMA,AHSA,ANkBA,AGTA,ADGA,AENA,AHSA,AS3BA,AKfA,AFMA,ACHA,AENA,ARwBA,AbuCA;AiBlDA,ADGA,AFMA,AHSA,ANkBA,AGTA,ADGA,AENA,AHSA,AS3BA,AKfA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ALeA,ADGA,AFMA,AHSA,ANkBA,AGTA,ADGA,AENA,AHSA,AS3BA,AKfA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ALeA,ADGA,AFMA,AHSA,ANkBA,AGTA,ADGA,AENA,AHSA,AS3BA,AKfA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ALeA,ADGA,AFMA,AHSA,ANkBA,AGTA,ADGA,AENA,AHSA,AS3BA,AKfA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,ANkBA,AGTA,ADGA,AENA,AHSA,Ac1CA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,ANkBA,AGTA,ADGA,AENA,AHSA,Ac1CA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,ANkBA,AGTA,ADGA,AENA,AHSA,Ac1CA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,ANkBA,AGTA,ACHA,AHSA,Ac1CA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AHSA,ACHA,AHSA,Ac1CA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AHSA,ACHA,AHSA,Ac1CA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AHSA,ACHA,AHSA,Ac1CA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AHSA,ACHA,AHSA,Ac1CA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AHSA,ACHA,AHSA,Ac1CA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AHSA,ACHA,AHSA,Ac1CA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AHSA,ACHA,AHSA,Ac1CA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AHSA,ACHA,AHSA,Ac1CA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AFMA,AHSA,Ac1CA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AFMA,AHSA,Ac1CA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AFMA,AHSA,Ac1CA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AFMA,AHSA,Ac1CA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AFMA,AHSA,Ac1CA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AFMA,AHSA,Ac1CA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AFMA,AHSA,Ac1CA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AFMA,AHSA,Ac1CA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AFMA,AWjCA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AS3BA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AS3BA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,AFMA,AHSA,AS3BA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AIZA,ANkBA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA,AbuCA;AsBjEA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AS1BA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AS1BA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AS1BA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AS1BA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AS1BA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AS1BA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AS1BA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AS1BA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AS1BA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AS1BA,ACHA,ANkBA,ADGA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,AFMA,ACHA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,ADGA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,ADGA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,ADGA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,ADGA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,ADGA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,ADGA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,ADGA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,ADGA,AENA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,ACHA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,ACHA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,ACHA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,ACHA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,ACHA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,ACHA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,ACHA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,ACHA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,ACHA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,ACHA,ARwBA;AU7BA,APqBA,ALeA,AS3BA,ACHA,ARwBA;AU7BA,AZoCA,AS3BA,ACHA,ARwBA;AU7BA,AZoCA,AS3BA,ACHA,ARwBA;AU7BA,AZoCA,AS3BA,ACHA,ARwBA;AU7BA,AZoCA,AS3BA,ACHA,ARwBA;AU7BA,AZoCA,AS3BA,ACHA,ARwBA;AU7BA,AZoCA,AS3BA,ACHA,ARwBA;AU7BA,AZoCA,AS3BA,ACHA,ARwBA;AU7BA,AZoCA,AS3BA,ACHA,ARwBA;AU7BA,AZoCA,AS3BA,ACHA,ARwBA;AU7BA,AZoCA,AS3BA,ACHA,ARwBA;AU7BA,AZoCA,AS3BA,ACHA,ARwBA;AU7BA,AZoCA,AS3BA,ACHA,ARwBA;AU7BA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AZoCA,AS3BA,ACHA;AELA,AHSA,ACHA;AELA,AHSA,ACHA;AELA,AHSA,ACHA;AELA,AHSA,ACHA;AELA,AHSA,ACHA;AELA,AHSA,ACHA;AELA,AHSA,ACHA;AELA,AHSA,ACHA;AELA,AHSA,ACHA;AELA,AHSA,ACHA;AELA,AHSA,ACHA;AELA,AHSA,ACHA;AELA,AHSA,ACHA;AELA,AHSA,ACHA;AELA,AHSA,ACHA","file":"index.js","sourcesContent":["\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./db\"));\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Geo = require(\"./geo\");\nconst collection_1 = require(\"./collection\");\nconst command_1 = require(\"./command\");\nconst serverDate_1 = require(\"./serverDate\");\nconst regexp_1 = require(\"./regexp\");\nclass Db {\n    constructor(config) {\n        this.config = config;\n        this.Geo = Geo;\n        this.serverDate = serverDate_1.ServerDateConstructor;\n        this.command = command_1.Command;\n        this.RegExp = regexp_1.RegExpConstructor;\n    }\n    collection(collName) {\n        if (!collName) {\n            throw new Error('Collection name is required');\n        }\n        return new collection_1.CollectionReference(this, collName);\n    }\n    createCollection(collName) {\n        let request = new Db.reqClass(this.config);\n        const params = {\n            collectionName: collName\n        };\n        return request.send('database.addCollection', params);\n    }\n}\nexports.Db = Db;\n","\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./point\"));\n__export(require(\"./lineString\"));\n__export(require(\"./polygon\"));\n__export(require(\"./multiPoint\"));\n__export(require(\"./multiLineString\"));\n__export(require(\"./multiPolygon\"));\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst validate_1 = require(\"../validate\");\nconst symbol_1 = require(\"../helper/symbol\");\nconst type_1 = require(\"../utils/type\");\nclass Point {\n    constructor(longitude, latitude) {\n        validate_1.Validate.isGeopoint('longitude', longitude);\n        validate_1.Validate.isGeopoint('latitude', latitude);\n        this.longitude = longitude;\n        this.latitude = latitude;\n    }\n    parse(key) {\n        return {\n            [key]: {\n                type: 'Point',\n                coordinates: [this.longitude, this.latitude]\n            }\n        };\n    }\n    toJSON() {\n        return {\n            type: 'Point',\n            coordinates: [\n                this.longitude,\n                this.latitude,\n            ],\n        };\n    }\n    toReadableString() {\n        return `[${this.longitude},${this.latitude}]`;\n    }\n    static validate(point) {\n        return point.type === 'Point' &&\n            type_1.isArray(point.coordinates) &&\n            validate_1.Validate.isGeopoint('longitude', point.coordinates[0]) &&\n            validate_1.Validate.isGeopoint('latitude', point.coordinates[1]);\n    }\n    get _internalType() {\n        return symbol_1.SYMBOL_GEO_POINT;\n    }\n}\nexports.Point = Point;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constant_1 = require(\"./constant\");\nconst util_1 = require(\"./util\");\nclass Validate {\n    static isGeopoint(point, degree) {\n        if (util_1.Util.whichType(degree) !== constant_1.FieldType.Number) {\n            throw new Error('Geo Point must be number type');\n        }\n        const degreeAbs = Math.abs(degree);\n        if (point === 'latitude' && degreeAbs > 90) {\n            throw new Error('latitude should be a number ranges from -90 to 90');\n        }\n        else if (point === 'longitude' && degreeAbs > 180) {\n            throw new Error('longitude should be a number ranges from -180 to 180');\n        }\n        return true;\n    }\n    static isInteger(param, num) {\n        if (!Number.isInteger(num)) {\n            throw new Error(param + constant_1.ErrorCode.IntergerError);\n        }\n        return true;\n    }\n    static isFieldOrder(direction) {\n        if (constant_1.OrderDirectionList.indexOf(direction) === -1) {\n            throw new Error(constant_1.ErrorCode.DirectionError);\n        }\n        return true;\n    }\n    static isFieldPath(path) {\n        if (!/^[a-zA-Z0-9-_\\.]/.test(path)) {\n            throw new Error();\n        }\n        return true;\n    }\n    static isOperator(op) {\n        if (constant_1.WhereFilterOpList.indexOf(op) === -1) {\n            throw new Error(constant_1.ErrorCode.OpStrError);\n        }\n        return true;\n    }\n    static isCollName(name) {\n        if (!/^[a-zA-Z0-9]([a-zA-Z0-9-_]){1,32}$/.test(name)) {\n            throw new Error(constant_1.ErrorCode.CollNameError);\n        }\n        return true;\n    }\n    static isDocID(docId) {\n        if (!/^([a-fA-F0-9]){24}$/.test(docId)) {\n            throw new Error(constant_1.ErrorCode.DocIDError);\n        }\n        return true;\n    }\n}\nexports.Validate = Validate;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[\"DocIDError\"] = \"\\u6587\\u6863ID\\u4E0D\\u5408\\u6CD5\";\n    ErrorCode[\"CollNameError\"] = \"\\u96C6\\u5408\\u540D\\u79F0\\u4E0D\\u5408\\u6CD5\";\n    ErrorCode[\"OpStrError\"] = \"\\u64CD\\u4F5C\\u7B26\\u4E0D\\u5408\\u6CD5\";\n    ErrorCode[\"DirectionError\"] = \"\\u6392\\u5E8F\\u5B57\\u7B26\\u4E0D\\u5408\\u6CD5\";\n    ErrorCode[\"IntergerError\"] = \"must be integer\";\n})(ErrorCode || (ErrorCode = {}));\nexports.ErrorCode = ErrorCode;\nconst FieldType = {\n    String: 'String',\n    Number: 'Number',\n    Object: 'Object',\n    Array: 'Array',\n    Boolean: 'Boolean',\n    Null: 'Null',\n    GeoPoint: 'GeoPoint',\n    GeoLineString: 'GeoLineString',\n    GeoPolygon: 'GeoPolygon',\n    GeoMultiPoint: 'GeoMultiPoint',\n    GeoMultiLineString: 'GeoMultiLineString',\n    GeoMultiPolygon: 'GeoMultiPolygon',\n    Timestamp: 'Date',\n    Command: 'Command',\n    ServerDate: 'ServerDate'\n};\nexports.FieldType = FieldType;\nconst OrderDirectionList = ['desc', 'asc'];\nexports.OrderDirectionList = OrderDirectionList;\nconst WhereFilterOpList = ['<', '<=', '==', '>=', '>'];\nexports.WhereFilterOpList = WhereFilterOpList;\nvar Opeartor;\n(function (Opeartor) {\n    Opeartor[\"lt\"] = \"<\";\n    Opeartor[\"gt\"] = \">\";\n    Opeartor[\"lte\"] = \"<=\";\n    Opeartor[\"gte\"] = \">=\";\n    Opeartor[\"eq\"] = \"==\";\n})(Opeartor || (Opeartor = {}));\nexports.Opeartor = Opeartor;\nconst OperatorMap = {\n    [Opeartor.eq]: '$eq',\n    [Opeartor.lt]: '$lt',\n    [Opeartor.lte]: '$lte',\n    [Opeartor.gt]: '$gt',\n    [Opeartor.gte]: '$gte'\n};\nexports.OperatorMap = OperatorMap;\nconst UpdateOperatorList = [\n    '$set',\n    '$inc',\n    '$mul',\n    '$unset',\n    '$push',\n    '$pop',\n    '$unshift',\n    '$shift',\n    '$currentDate',\n    '$each',\n    '$position'\n];\nexports.UpdateOperatorList = UpdateOperatorList;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constant_1 = require(\"./constant\");\nconst geo_1 = require(\"./geo\");\nconst serverDate_1 = require(\"./serverDate\");\nclass Util {\n}\nUtil.formatResDocumentData = (documents) => {\n    return documents.map(document => {\n        return Util.formatField(document);\n    });\n};\nUtil.formatField = document => {\n    const keys = Object.keys(document);\n    let protoField = {};\n    if (Array.isArray(document)) {\n        protoField = [];\n    }\n    keys.forEach(key => {\n        const item = document[key];\n        const type = Util.whichType(item);\n        let realValue;\n        switch (type) {\n            case constant_1.FieldType.GeoPoint:\n                realValue = new geo_1.Point(item.coordinates[0], item.coordinates[1]);\n                break;\n            case constant_1.FieldType.GeoLineString:\n                realValue = new geo_1.LineString(item.coordinates.map(point => new geo_1.Point(point[0], point[1])));\n                break;\n            case constant_1.FieldType.GeoPolygon:\n                realValue = new geo_1.Polygon(item.coordinates.map(line => new geo_1.LineString(line.map(([lng, lat]) => new geo_1.Point(lng, lat)))));\n                break;\n            case constant_1.FieldType.GeoMultiPoint:\n                realValue = new geo_1.MultiPoint(item.coordinates.map(point => new geo_1.Point(point[0], point[1])));\n                break;\n            case constant_1.FieldType.GeoMultiLineString:\n                realValue = new geo_1.MultiLineString(item.coordinates.map(line => new geo_1.LineString(line.map(([lng, lat]) => new geo_1.Point(lng, lat)))));\n                break;\n            case constant_1.FieldType.GeoMultiPolygon:\n                realValue = new geo_1.MultiPolygon(item.coordinates.map(polygon => new geo_1.Polygon(polygon.map(line => new geo_1.LineString(line.map(([lng, lat]) => new geo_1.Point(lng, lat)))))));\n                break;\n            case constant_1.FieldType.Timestamp:\n                realValue = new Date(item.$timestamp * 1000);\n                break;\n            case constant_1.FieldType.Object:\n            case constant_1.FieldType.Array:\n                realValue = Util.formatField(item);\n                break;\n            case constant_1.FieldType.ServerDate:\n                realValue = new Date(item.$date);\n                break;\n            default:\n                realValue = item;\n        }\n        if (Array.isArray(protoField)) {\n            protoField.push(realValue);\n        }\n        else {\n            protoField[key] = realValue;\n        }\n    });\n    return protoField;\n};\nUtil.whichType = (obj) => {\n    let type = Object.prototype.toString.call(obj).slice(8, -1);\n    if (type === constant_1.FieldType.Object) {\n        if (obj instanceof geo_1.Point) {\n            return constant_1.FieldType.GeoPoint;\n        }\n        else if (obj instanceof Date) {\n            return constant_1.FieldType.Timestamp;\n        }\n        else if (obj instanceof serverDate_1.ServerDate) {\n            return constant_1.FieldType.ServerDate;\n        }\n        if (obj.$timestamp) {\n            type = constant_1.FieldType.Timestamp;\n        }\n        else if (obj.$date) {\n            type = constant_1.FieldType.ServerDate;\n        }\n        else if (geo_1.Point.validate(obj)) {\n            type = constant_1.FieldType.GeoPoint;\n        }\n        else if (geo_1.LineString.validate(obj)) {\n            type = constant_1.FieldType.GeoLineString;\n        }\n        else if (geo_1.Polygon.validate(obj)) {\n            type = constant_1.FieldType.GeoPolygon;\n        }\n        else if (geo_1.MultiPoint.validate(obj)) {\n            type = constant_1.FieldType.GeoMultiPoint;\n        }\n        else if (geo_1.MultiLineString.validate(obj)) {\n            type = constant_1.FieldType.GeoMultiLineString;\n        }\n        else if (geo_1.MultiPolygon.validate(obj)) {\n            type = constant_1.FieldType.GeoMultiPolygon;\n        }\n    }\n    return type;\n};\nUtil.generateDocId = () => {\n    let chars = 'ABCDEFabcdef0123456789';\n    let autoId = '';\n    for (let i = 0; i < 24; i++) {\n        autoId += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return autoId;\n};\nexports.Util = Util;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../helper/symbol\");\nclass ServerDate {\n    constructor({ offset = 0 } = {}) {\n        this.offset = offset;\n    }\n    get _internalType() {\n        return symbol_1.SYMBOL_SERVER_DATE;\n    }\n    parse() {\n        return {\n            $date: {\n                offset: this.offset\n            }\n        };\n    }\n}\nexports.ServerDate = ServerDate;\nfunction ServerDateConstructor(opt) {\n    return new ServerDate(opt);\n}\nexports.ServerDateConstructor = ServerDateConstructor;\n","\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../utils/symbol\");\n__export(require(\"../utils/symbol\"));\nexports.SYMBOL_UNSET_FIELD_NAME = symbol_1.default.for('UNSET_FIELD_NAME');\nexports.SYMBOL_UPDATE_COMMAND = symbol_1.default.for('UPDATE_COMMAND');\nexports.SYMBOL_QUERY_COMMAND = symbol_1.default.for('QUERY_COMMAND');\nexports.SYMBOL_LOGIC_COMMAND = symbol_1.default.for('LOGIC_COMMAND');\nexports.SYMBOL_GEO_POINT = symbol_1.default.for('GEO_POINT');\nexports.SYMBOL_GEO_LINE_STRING = symbol_1.default.for('SYMBOL_GEO_LINE_STRING');\nexports.SYMBOL_GEO_POLYGON = symbol_1.default.for('SYMBOL_GEO_POLYGON');\nexports.SYMBOL_GEO_MULTI_POINT = symbol_1.default.for('SYMBOL_GEO_MULTI_POINT');\nexports.SYMBOL_GEO_MULTI_LINE_STRING = symbol_1.default.for('SYMBOL_GEO_MULTI_LINE_STRING');\nexports.SYMBOL_GEO_MULTI_POLYGON = symbol_1.default.for('SYMBOL_GEO_MULTI_POLYGON');\nexports.SYMBOL_SERVER_DATE = symbol_1.default.for('SERVER_DATE');\nexports.SYMBOL_REGEXP = symbol_1.default.for('REGEXP');\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _symbols = [];\nconst __internalMark__ = {};\nclass HiddenSymbol {\n    constructor(target) {\n        Object.defineProperties(this, {\n            target: {\n                enumerable: false,\n                writable: false,\n                configurable: false,\n                value: target,\n            },\n        });\n    }\n}\nclass InternalSymbol extends HiddenSymbol {\n    constructor(target, __mark__) {\n        if (__mark__ !== __internalMark__) {\n            throw new TypeError('InternalSymbol cannot be constructed with new operator');\n        }\n        super(target);\n    }\n    static for(target) {\n        for (let i = 0, len = _symbols.length; i < len; i++) {\n            if (_symbols[i].target === target) {\n                return _symbols[i].instance;\n            }\n        }\n        const symbol = new InternalSymbol(target, __internalMark__);\n        _symbols.push({\n            target,\n            instance: symbol,\n        });\n        return symbol;\n    }\n}\nexports.InternalSymbol = InternalSymbol;\nexports.default = InternalSymbol;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"./symbol\");\nexports.getType = (x) => Object.prototype.toString.call(x).slice(8, -1).toLowerCase();\nexports.isObject = (x) => exports.getType(x) === 'object';\nexports.isString = (x) => exports.getType(x) === 'string';\nexports.isNumber = (x) => exports.getType(x) === 'number';\nexports.isPromise = (x) => exports.getType(x) === 'promise';\nexports.isFunction = (x) => typeof x === 'function';\nexports.isArray = (x) => Array.isArray(x);\nexports.isDate = (x) => exports.getType(x) === 'date';\nexports.isRegExp = (x) => exports.getType(x) === 'regexp';\nexports.isInternalObject = (x) => x && (x._internalType instanceof symbol_1.InternalSymbol);\nexports.isPlainObject = (obj) => {\n    if (typeof obj !== 'object' || obj === null)\n        return false;\n    let proto = obj;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(obj) === proto;\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../helper/symbol\");\nconst point_1 = require(\"./point\");\nconst type_1 = require(\"../utils/type\");\nclass LineString {\n    constructor(points) {\n        if (!type_1.isArray(points)) {\n            throw new TypeError(`\"points\" must be of type Point[]. Received type ${typeof points}`);\n        }\n        if (points.length < 2) {\n            throw new Error('\"points\" must contain 2 points at least');\n        }\n        points.forEach(point => {\n            if (!(point instanceof point_1.Point)) {\n                throw new TypeError(`\"points\" must be of type Point[]. Received type ${typeof point}[]`);\n            }\n        });\n        this.points = points;\n    }\n    parse(key) {\n        return {\n            [key]: {\n                type: 'LineString',\n                coordinates: this.points.map(point => point.toJSON().coordinates)\n            }\n        };\n    }\n    toJSON() {\n        return {\n            type: 'LineString',\n            coordinates: this.points.map(point => point.toJSON().coordinates)\n        };\n    }\n    static validate(lineString) {\n        if (lineString.type !== 'LineString' || !type_1.isArray(lineString.coordinates)) {\n            return false;\n        }\n        for (let point of lineString.coordinates) {\n            if (!type_1.isNumber(point[0]) || !type_1.isNumber(point[1])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static isClosed(lineString) {\n        const firstPoint = lineString.points[0];\n        const lastPoint = lineString.points[lineString.points.length - 1];\n        if (firstPoint.latitude === lastPoint.latitude && firstPoint.longitude === lastPoint.longitude) {\n            return true;\n        }\n    }\n    get _internalType() {\n        return symbol_1.SYMBOL_GEO_LINE_STRING;\n    }\n}\nexports.LineString = LineString;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../helper/symbol\");\nconst type_1 = require(\"../utils/type\");\nconst lineString_1 = require(\"./lineString\");\nclass Polygon {\n    constructor(lines) {\n        if (!type_1.isArray(lines)) {\n            throw new TypeError(`\"lines\" must be of type LineString[]. Received type ${typeof lines}`);\n        }\n        if (lines.length === 0) {\n            throw new Error('Polygon must contain 1 linestring at least');\n        }\n        lines.forEach(line => {\n            if (!(line instanceof lineString_1.LineString)) {\n                throw new TypeError(`\"lines\" must be of type LineString[]. Received type ${typeof line}[]`);\n            }\n            if (!lineString_1.LineString.isClosed(line)) {\n                throw new Error(`LineString ${line.points.map(p => p.toReadableString())} is not a closed cycle`);\n            }\n        });\n        this.lines = lines;\n    }\n    parse(key) {\n        return {\n            [key]: {\n                type: 'Polygon',\n                coordinates: this.lines.map(line => {\n                    return line.points.map(point => [point.longitude, point.latitude]);\n                })\n            }\n        };\n    }\n    toJSON() {\n        return {\n            type: 'Polygon',\n            coordinates: this.lines.map(line => {\n                return line.points.map(point => [point.longitude, point.latitude]);\n            })\n        };\n    }\n    static validate(polygon) {\n        if (polygon.type !== 'Polygon' || !type_1.isArray(polygon.coordinates)) {\n            return false;\n        }\n        for (let line of polygon.coordinates) {\n            if (!this.isCloseLineString(line)) {\n                return false;\n            }\n            for (let point of line) {\n                if (!type_1.isNumber(point[0]) || !type_1.isNumber(point[1])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static isCloseLineString(lineString) {\n        const firstPoint = lineString[0];\n        const lastPoint = lineString[lineString.length - 1];\n        if (firstPoint[0] !== lastPoint[0] || firstPoint[1] !== lastPoint[1]) {\n            return false;\n        }\n        return true;\n    }\n    get _internalType() {\n        return symbol_1.SYMBOL_GEO_MULTI_POLYGON;\n    }\n}\nexports.Polygon = Polygon;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../helper/symbol\");\nconst point_1 = require(\"./point\");\nconst type_1 = require(\"../utils/type\");\nclass MultiPoint {\n    constructor(points) {\n        if (!type_1.isArray(points)) {\n            throw new TypeError(`\"points\" must be of type Point[]. Received type ${typeof points}`);\n        }\n        if (points.length === 0) {\n            throw new Error('\"points\" must contain 1 point at least');\n        }\n        points.forEach(point => {\n            if (!(point instanceof point_1.Point)) {\n                throw new TypeError(`\"points\" must be of type Point[]. Received type ${typeof point}[]`);\n            }\n        });\n        this.points = points;\n    }\n    parse(key) {\n        return {\n            [key]: {\n                type: 'MultiPoint',\n                coordinates: this.points.map(point => point.toJSON().coordinates)\n            }\n        };\n    }\n    toJSON() {\n        return {\n            type: 'MultiPoint',\n            coordinates: this.points.map(point => point.toJSON().coordinates)\n        };\n    }\n    static validate(multiPoint) {\n        if (multiPoint.type !== 'MultiPoint' || !type_1.isArray(multiPoint.coordinates)) {\n            return false;\n        }\n        for (let point of multiPoint.coordinates) {\n            if (!type_1.isNumber(point[0]) || !type_1.isNumber(point[1])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    get _internalType() {\n        return symbol_1.SYMBOL_GEO_MULTI_POINT;\n    }\n}\nexports.MultiPoint = MultiPoint;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../helper/symbol\");\nconst type_1 = require(\"../utils/type\");\nconst lineString_1 = require(\"./lineString\");\nclass MultiLineString {\n    constructor(lines) {\n        if (!type_1.isArray(lines)) {\n            throw new TypeError(`\"lines\" must be of type LineString[]. Received type ${typeof lines}`);\n        }\n        if (lines.length === 0) {\n            throw new Error('Polygon must contain 1 linestring at least');\n        }\n        lines.forEach(line => {\n            if (!(line instanceof lineString_1.LineString)) {\n                throw new TypeError(`\"lines\" must be of type LineString[]. Received type ${typeof line}[]`);\n            }\n        });\n        this.lines = lines;\n    }\n    parse(key) {\n        return {\n            [key]: {\n                type: 'MultiLineString',\n                coordinates: this.lines.map(line => {\n                    return line.points.map(point => [point.longitude, point.latitude]);\n                })\n            }\n        };\n    }\n    toJSON() {\n        return {\n            type: 'MultiLineString',\n            coordinates: this.lines.map(line => {\n                return line.points.map(point => [point.longitude, point.latitude]);\n            })\n        };\n    }\n    static validate(multiLineString) {\n        if (multiLineString.type !== 'MultiLineString' || !type_1.isArray(multiLineString.coordinates)) {\n            return false;\n        }\n        for (let line of multiLineString.coordinates) {\n            for (let point of line) {\n                if (!type_1.isNumber(point[0]) || !type_1.isNumber(point[1])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    get _internalType() {\n        return symbol_1.SYMBOL_GEO_MULTI_LINE_STRING;\n    }\n}\nexports.MultiLineString = MultiLineString;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../helper/symbol\");\nconst type_1 = require(\"../utils/type\");\nconst polygon_1 = require(\"./polygon\");\nclass MultiPolygon {\n    constructor(polygons) {\n        if (!type_1.isArray(polygons)) {\n            throw new TypeError(`\"polygons\" must be of type Polygon[]. Received type ${typeof polygons}`);\n        }\n        if (polygons.length === 0) {\n            throw new Error('MultiPolygon must contain 1 polygon at least');\n        }\n        for (let polygon of polygons) {\n            if (!(polygon instanceof polygon_1.Polygon)) {\n                throw new TypeError(`\"polygon\" must be of type Polygon[]. Received type ${typeof polygon}[]`);\n            }\n        }\n        this.polygons = polygons;\n    }\n    parse(key) {\n        return {\n            [key]: {\n                type: 'MultiPolygon',\n                coordinates: this.polygons.map(polygon => {\n                    return polygon.lines.map(line => {\n                        return line.points.map(point => [point.longitude, point.latitude]);\n                    });\n                })\n            }\n        };\n    }\n    toJSON() {\n        return {\n            type: 'MultiPolygon',\n            coordinates: this.polygons.map(polygon => {\n                return polygon.lines.map(line => {\n                    return line.points.map(point => [point.longitude, point.latitude]);\n                });\n            })\n        };\n    }\n    static validate(multiPolygon) {\n        if (multiPolygon.type !== 'MultiPolygon' || !type_1.isArray(multiPolygon.coordinates)) {\n            return false;\n        }\n        for (let polygon of multiPolygon.coordinates) {\n            for (let line of polygon) {\n                for (let point of line) {\n                    if (!type_1.isNumber(point[0]) || !type_1.isNumber(point[1])) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    get _internalType() {\n        return symbol_1.SYMBOL_GEO_POLYGON;\n    }\n}\nexports.MultiPolygon = MultiPolygon;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst document_1 = require(\"./document\");\nconst query_1 = require(\"./query\");\nconst aggregate_1 = require(\"./aggregate\");\nclass CollectionReference extends query_1.Query {\n    constructor(db, coll) {\n        super(db, coll);\n    }\n    get name() {\n        return this._coll;\n    }\n    doc(docID) {\n        return new document_1.DocumentReference(this._db, this._coll, docID);\n    }\n    add(data, callback) {\n        let docRef = this.doc();\n        return docRef.create(data, callback);\n    }\n    aggregate() {\n        return new aggregate_1.default(this._db, this._coll);\n    }\n}\nexports.CollectionReference = CollectionReference;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"./lib/util\");\nconst db_1 = require(\"./db\");\nconst util_2 = require(\"./util\");\nconst update_1 = require(\"./serializer/update\");\nconst datatype_1 = require(\"./serializer/datatype\");\nconst update_2 = require(\"./commands/update\");\nclass DocumentReference {\n    constructor(db, coll, docID, projection = {}) {\n        this._db = db;\n        this._coll = coll;\n        this.id = docID;\n        this.request = new db_1.Db.reqClass(this._db.config);\n        this.projection = projection;\n    }\n    create(data, callback) {\n        callback = callback || util_1.createPromiseCallback();\n        let params = {\n            collectionName: this._coll,\n            data: datatype_1.serialize(data)\n        };\n        if (this.id) {\n            params['_id'] = this.id;\n        }\n        this.request.send('database.addDocument', params).then(res => {\n            if (res.code) {\n                callback(0, res);\n            }\n            else {\n                callback(0, {\n                    id: res.data._id,\n                    requestId: res.requestId\n                });\n            }\n        }).catch((err) => {\n            callback(err);\n        });\n        return callback.promise;\n    }\n    set(data, callback) {\n        callback = callback || util_1.createPromiseCallback();\n        if (!data || typeof data !== 'object') {\n            return Promise.resolve({\n                code: 'INVALID_PARAM',\n                message: '参数必需是非空对象'\n            });\n        }\n        if (data.hasOwnProperty('_id')) {\n            return Promise.resolve({\n                code: 'INVALID_PARAM',\n                message: '不能更新_id的值'\n            });\n        }\n        let hasOperator = false;\n        const checkMixed = (objs) => {\n            if (typeof objs === 'object') {\n                for (let key in objs) {\n                    if (objs[key] instanceof update_2.UpdateCommand) {\n                        hasOperator = true;\n                    }\n                    else if (typeof objs[key] === 'object') {\n                        checkMixed(objs[key]);\n                    }\n                }\n            }\n        };\n        checkMixed(data);\n        if (hasOperator) {\n            return Promise.resolve({\n                code: 'DATABASE_REQUEST_FAILED',\n                message: 'update operator complicit'\n            });\n        }\n        const merge = false;\n        let param = {\n            collectionName: this._coll,\n            data: datatype_1.serialize(data),\n            multi: false,\n            merge,\n            upsert: true\n        };\n        if (this.id) {\n            param['query'] = { _id: this.id };\n        }\n        this.request.send('database.updateDocument', param).then(res => {\n            if (res.code) {\n                callback(0, res);\n            }\n            else {\n                callback(0, {\n                    updated: res.data.updated,\n                    upsertedId: res.data.upserted_id,\n                    requestId: res.requestId\n                });\n            }\n        }).catch((err) => {\n            callback(err);\n        });\n        return callback.promise;\n    }\n    update(data, callback) {\n        callback = callback || util_1.createPromiseCallback();\n        if (!data || typeof data !== 'object') {\n            return Promise.resolve({\n                code: 'INVALID_PARAM',\n                message: '参数必需是非空对象'\n            });\n        }\n        if (data.hasOwnProperty('_id')) {\n            return Promise.resolve({\n                code: 'INVALID_PARAM',\n                message: '不能更新_id的值'\n            });\n        }\n        const query = { _id: this.id };\n        const merge = true;\n        const param = {\n            collectionName: this._coll,\n            data: update_1.UpdateSerializer.encode(data),\n            query: query,\n            multi: false,\n            merge,\n            upsert: false\n        };\n        this.request.send('database.updateDocument', param).then(res => {\n            if (res.code) {\n                callback(0, res);\n            }\n            else {\n                callback(0, {\n                    updated: res.data.updated,\n                    upsertedId: res.data.upserted_id,\n                    requestId: res.requestId\n                });\n            }\n        }).catch((err) => {\n            callback(err);\n        });\n        return callback.promise;\n    }\n    remove(callback) {\n        callback = callback || util_1.createPromiseCallback();\n        const query = { _id: this.id };\n        const param = {\n            collectionName: this._coll,\n            query: query,\n            multi: false\n        };\n        this.request.send('database.deleteDocument', param).then(res => {\n            if (res.code) {\n                callback(0, res);\n            }\n            else {\n                callback(0, {\n                    deleted: res.data.deleted,\n                    requestId: res.requestId\n                });\n            }\n        }).catch((err) => {\n            callback(err);\n        });\n        return callback.promise;\n    }\n    get(callback) {\n        callback = callback || util_1.createPromiseCallback();\n        const query = { _id: this.id };\n        const param = {\n            collectionName: this._coll,\n            query: query,\n            multi: false,\n            projection: this.projection\n        };\n        this.request.send('database.queryDocument', param).then(res => {\n            if (res.code) {\n                callback(0, res);\n            }\n            else {\n                const documents = util_2.Util.formatResDocumentData(res.data.list);\n                callback(0, {\n                    data: documents,\n                    requestId: res.requestId,\n                    total: res.TotalCount,\n                    limit: res.Limit,\n                    offset: res.Offset\n                });\n            }\n        }).catch((err) => {\n            callback(err);\n        });\n        return callback.promise;\n    }\n    field(projection) {\n        for (let k in projection) {\n            if (projection[k]) {\n                projection[k] = 1;\n            }\n            else {\n                projection[k] = 0;\n            }\n        }\n        return new DocumentReference(this._db, this._coll, this.id, projection);\n    }\n}\nexports.DocumentReference = DocumentReference;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createPromiseCallback = () => {\n    let cb;\n    if (!Promise) {\n        cb = () => { };\n        cb.promise = {};\n        const throwPromiseNotDefined = () => {\n            throw new Error('Your Node runtime does support ES6 Promises. ' +\n                'Set \"global.Promise\" to your preferred implementation of promises.');\n        };\n        Object.defineProperty(cb.promise, 'then', { get: throwPromiseNotDefined });\n        Object.defineProperty(cb.promise, 'catch', { get: throwPromiseNotDefined });\n        return cb;\n    }\n    const promise = new Promise((resolve, reject) => {\n        cb = (err, data) => {\n            if (err)\n                return reject(err);\n            return resolve(data);\n        };\n    });\n    cb.promise = promise;\n    return cb;\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst update_1 = require(\"../commands/update\");\nconst symbol_1 = require(\"../helper/symbol\");\nconst type_1 = require(\"../utils/type\");\nconst operator_map_1 = require(\"../operator-map\");\nconst common_1 = require(\"./common\");\nclass UpdateSerializer {\n    constructor() {\n    }\n    static encode(query) {\n        const stringifier = new UpdateSerializer();\n        return stringifier.encodeUpdate(query);\n    }\n    encodeUpdate(query) {\n        if (update_1.isUpdateCommand(query)) {\n            return this.encodeUpdateCommand(query);\n        }\n        else if (type_1.getType(query) === 'object') {\n            return this.encodeUpdateObject(query);\n        }\n        else {\n            return query;\n        }\n    }\n    encodeUpdateCommand(query) {\n        if (query.fieldName === symbol_1.SYMBOL_UNSET_FIELD_NAME) {\n            throw new Error('Cannot encode a comparison command with unset field name');\n        }\n        switch (query.operator) {\n            case update_1.UPDATE_COMMANDS_LITERAL.SET:\n            case update_1.UPDATE_COMMANDS_LITERAL.REMOVE:\n            case update_1.UPDATE_COMMANDS_LITERAL.INC:\n            case update_1.UPDATE_COMMANDS_LITERAL.MUL: {\n                return this.encodeFieldUpdateCommand(query);\n            }\n            case update_1.UPDATE_COMMANDS_LITERAL.PUSH:\n            case update_1.UPDATE_COMMANDS_LITERAL.POP:\n            case update_1.UPDATE_COMMANDS_LITERAL.SHIFT:\n            case update_1.UPDATE_COMMANDS_LITERAL.UNSHIFT: {\n                return this.encodeArrayUpdateCommand(query);\n            }\n            default: {\n                return this.encodeFieldUpdateCommand(query);\n            }\n        }\n    }\n    encodeFieldUpdateCommand(query) {\n        const $op = operator_map_1.operatorToString(query.operator);\n        switch (query.operator) {\n            case update_1.UPDATE_COMMANDS_LITERAL.REMOVE: {\n                return {\n                    [$op]: {\n                        [query.fieldName]: '',\n                    },\n                };\n            }\n            case update_1.UPDATE_COMMANDS_LITERAL.SET:\n            case update_1.UPDATE_COMMANDS_LITERAL.INC:\n            case update_1.UPDATE_COMMANDS_LITERAL.MUL:\n            default: {\n                return {\n                    [$op]: {\n                        [query.fieldName]: query.operands[0],\n                    },\n                };\n            }\n        }\n    }\n    encodeArrayUpdateCommand(query) {\n        const $op = operator_map_1.operatorToString(query.operator);\n        switch (query.operator) {\n            case update_1.UPDATE_COMMANDS_LITERAL.PUSH: {\n                const modifiers = {\n                    $each: query.operands.map(common_1.encodeInternalDataType),\n                };\n                return {\n                    [$op]: {\n                        [query.fieldName]: modifiers,\n                    },\n                };\n            }\n            case update_1.UPDATE_COMMANDS_LITERAL.UNSHIFT: {\n                const modifiers = {\n                    $each: query.operands.map(common_1.encodeInternalDataType),\n                    $position: 0,\n                };\n                return {\n                    [$op]: {\n                        [query.fieldName]: modifiers,\n                    },\n                };\n            }\n            case update_1.UPDATE_COMMANDS_LITERAL.POP: {\n                return {\n                    [$op]: {\n                        [query.fieldName]: 1,\n                    },\n                };\n            }\n            case update_1.UPDATE_COMMANDS_LITERAL.SHIFT: {\n                return {\n                    [$op]: {\n                        [query.fieldName]: -1,\n                    },\n                };\n            }\n            default: {\n                return {\n                    [$op]: {\n                        [query.fieldName]: common_1.encodeInternalDataType(query.operands),\n                    },\n                };\n            }\n        }\n    }\n    encodeUpdateObject(query) {\n        const flattened = common_1.flattenQueryObject(query);\n        for (const key in flattened) {\n            if (/^\\$/.test(key))\n                continue;\n            let val = flattened[key];\n            if (update_1.isUpdateCommand(val)) {\n                flattened[key] = val._setFieldName(key);\n                const condition = this.encodeUpdateCommand(flattened[key]);\n                common_1.mergeConditionAfterEncode(flattened, condition, key);\n            }\n            else {\n                flattened[key] = val = common_1.encodeInternalDataType(val);\n                const $setCommand = new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.SET, [val], key);\n                const condition = this.encodeUpdateCommand($setCommand);\n                common_1.mergeConditionAfterEncode(flattened, condition, key);\n            }\n        }\n        return flattened;\n    }\n}\nexports.UpdateSerializer = UpdateSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../helper/symbol\");\nexports.SET = 'set';\nexports.REMOVE = 'remove';\nexports.INC = 'inc';\nexports.MUL = 'mul';\nexports.PUSH = 'push';\nexports.POP = 'pop';\nexports.SHIFT = 'shift';\nexports.UNSHIFT = 'unshift';\nvar UPDATE_COMMANDS_LITERAL;\n(function (UPDATE_COMMANDS_LITERAL) {\n    UPDATE_COMMANDS_LITERAL[\"SET\"] = \"set\";\n    UPDATE_COMMANDS_LITERAL[\"REMOVE\"] = \"remove\";\n    UPDATE_COMMANDS_LITERAL[\"INC\"] = \"inc\";\n    UPDATE_COMMANDS_LITERAL[\"MUL\"] = \"mul\";\n    UPDATE_COMMANDS_LITERAL[\"PUSH\"] = \"push\";\n    UPDATE_COMMANDS_LITERAL[\"POP\"] = \"pop\";\n    UPDATE_COMMANDS_LITERAL[\"SHIFT\"] = \"shift\";\n    UPDATE_COMMANDS_LITERAL[\"UNSHIFT\"] = \"unshift\";\n})(UPDATE_COMMANDS_LITERAL = exports.UPDATE_COMMANDS_LITERAL || (exports.UPDATE_COMMANDS_LITERAL = {}));\nclass UpdateCommand {\n    constructor(operator, operands, fieldName) {\n        this._internalType = symbol_1.SYMBOL_UPDATE_COMMAND;\n        Object.defineProperties(this, {\n            _internalType: {\n                enumerable: false,\n                configurable: false,\n            },\n        });\n        this.operator = operator;\n        this.operands = operands;\n        this.fieldName = fieldName || symbol_1.SYMBOL_UNSET_FIELD_NAME;\n    }\n    _setFieldName(fieldName) {\n        const command = new UpdateCommand(this.operator, this.operands, fieldName);\n        return command;\n    }\n}\nexports.UpdateCommand = UpdateCommand;\nfunction isUpdateCommand(object) {\n    return object && (object instanceof UpdateCommand) && (object._internalType === symbol_1.SYMBOL_UPDATE_COMMAND);\n}\nexports.isUpdateCommand = isUpdateCommand;\nfunction isKnownUpdateCommand(object) {\n    return isUpdateCommand(object) && (object.operator.toUpperCase() in UPDATE_COMMANDS_LITERAL);\n}\nexports.isKnownUpdateCommand = isKnownUpdateCommand;\nexports.default = UpdateCommand;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst query_1 = require(\"./commands/query\");\nconst logic_1 = require(\"./commands/logic\");\nconst update_1 = require(\"./commands/update\");\nexports.OperatorMap = {};\nfor (const key in query_1.QUERY_COMMANDS_LITERAL) {\n    exports.OperatorMap[key] = `$${key.toLowerCase()}`;\n}\nfor (const key in logic_1.LOGIC_COMMANDS_LITERAL) {\n    exports.OperatorMap[key] = `$${key.toLowerCase()}`;\n}\nfor (const key in update_1.UPDATE_COMMANDS_LITERAL) {\n    exports.OperatorMap[key] = `$${key.toLowerCase()}`;\n}\nexports.OperatorMap[query_1.QUERY_COMMANDS_LITERAL.NEQ] = '$ne';\nexports.OperatorMap[update_1.UPDATE_COMMANDS_LITERAL.REMOVE] = '$unset';\nexports.OperatorMap[update_1.UPDATE_COMMANDS_LITERAL.SHIFT] = '$pop';\nexports.OperatorMap[update_1.UPDATE_COMMANDS_LITERAL.UNSHIFT] = '$push';\nfunction operatorToString(operator) {\n    return exports.OperatorMap[operator] || `$${operator.toLowerCase()}`;\n}\nexports.operatorToString = operatorToString;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst logic_1 = require(\"./logic\");\nconst symbol_1 = require(\"../helper/symbol\");\nconst geo_1 = require(\"../geo\");\nconst type_1 = require(\"../utils/type\");\nexports.EQ = 'eq';\nexports.NEQ = 'neq';\nexports.GT = 'gt';\nexports.GTE = 'gte';\nexports.LT = 'lt';\nexports.LTE = 'lte';\nexports.IN = 'in';\nexports.NIN = 'nin';\nvar QUERY_COMMANDS_LITERAL;\n(function (QUERY_COMMANDS_LITERAL) {\n    QUERY_COMMANDS_LITERAL[\"EQ\"] = \"eq\";\n    QUERY_COMMANDS_LITERAL[\"NEQ\"] = \"neq\";\n    QUERY_COMMANDS_LITERAL[\"GT\"] = \"gt\";\n    QUERY_COMMANDS_LITERAL[\"GTE\"] = \"gte\";\n    QUERY_COMMANDS_LITERAL[\"LT\"] = \"lt\";\n    QUERY_COMMANDS_LITERAL[\"LTE\"] = \"lte\";\n    QUERY_COMMANDS_LITERAL[\"IN\"] = \"in\";\n    QUERY_COMMANDS_LITERAL[\"NIN\"] = \"nin\";\n    QUERY_COMMANDS_LITERAL[\"GEO_NEAR\"] = \"geoNear\";\n    QUERY_COMMANDS_LITERAL[\"GEO_WITHIN\"] = \"geoWithin\";\n    QUERY_COMMANDS_LITERAL[\"GEO_INTERSECTS\"] = \"geoIntersects\";\n})(QUERY_COMMANDS_LITERAL = exports.QUERY_COMMANDS_LITERAL || (exports.QUERY_COMMANDS_LITERAL = {}));\nclass QueryCommand extends logic_1.LogicCommand {\n    constructor(operator, operands, fieldName) {\n        super(operator, operands, fieldName);\n        this.operator = operator;\n        this._internalType = symbol_1.SYMBOL_QUERY_COMMAND;\n    }\n    _setFieldName(fieldName) {\n        const command = new QueryCommand(this.operator, this.operands, fieldName);\n        return command;\n    }\n    eq(val) {\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.EQ, [val], this.fieldName);\n        return this.and(command);\n    }\n    neq(val) {\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.NEQ, [val], this.fieldName);\n        return this.and(command);\n    }\n    gt(val) {\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.GT, [val], this.fieldName);\n        return this.and(command);\n    }\n    gte(val) {\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.GTE, [val], this.fieldName);\n        return this.and(command);\n    }\n    lt(val) {\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.LT, [val], this.fieldName);\n        return this.and(command);\n    }\n    lte(val) {\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.LTE, [val], this.fieldName);\n        return this.and(command);\n    }\n    in(list) {\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.IN, list, this.fieldName);\n        return this.and(command);\n    }\n    nin(list) {\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.NIN, list, this.fieldName);\n        return this.and(command);\n    }\n    geoNear(val) {\n        if (!(val.geometry instanceof geo_1.Point)) {\n            throw new TypeError(`\"geometry\" must be of type Point. Received type ${typeof val.geometry}`);\n        }\n        if (val.maxDistance !== undefined && !type_1.isNumber(val.maxDistance)) {\n            throw new TypeError(`\"maxDistance\" must be of type Number. Received type ${typeof val.maxDistance}`);\n        }\n        if (val.minDistance !== undefined && !type_1.isNumber(val.minDistance)) {\n            throw new TypeError(`\"minDistance\" must be of type Number. Received type ${typeof val.minDistance}`);\n        }\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.GEO_NEAR, [val], this.fieldName);\n        return this.and(command);\n    }\n    geoWithin(val) {\n        if (!(val.geometry instanceof geo_1.MultiPolygon) && !(val.geometry instanceof geo_1.Polygon)) {\n            throw new TypeError(`\"geometry\" must be of type Polygon or MultiPolygon. Received type ${typeof val.geometry}`);\n        }\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.GEO_WITHIN, [val], this.fieldName);\n        return this.and(command);\n    }\n    geoIntersects(val) {\n        if (!(val.geometry instanceof geo_1.Point) &&\n            !(val.geometry instanceof geo_1.LineString) &&\n            !(val.geometry instanceof geo_1.Polygon) &&\n            !(val.geometry instanceof geo_1.MultiPoint) &&\n            !(val.geometry instanceof geo_1.MultiLineString) &&\n            !(val.geometry instanceof geo_1.MultiPolygon)) {\n            throw new TypeError(`\"geometry\" must be of type Point, LineString, Polygon, MultiPoint, MultiLineString or MultiPolygon. Received type ${typeof val.geometry}`);\n        }\n        const command = new QueryCommand(QUERY_COMMANDS_LITERAL.GEO_INTERSECTS, [val], this.fieldName);\n        return this.and(command);\n    }\n}\nexports.QueryCommand = QueryCommand;\nfunction isQueryCommand(object) {\n    return object && object instanceof QueryCommand && object._internalType === symbol_1.SYMBOL_QUERY_COMMAND;\n}\nexports.isQueryCommand = isQueryCommand;\nfunction isKnownQueryCommand(object) {\n    return isQueryCommand(object) && object.operator.toUpperCase() in QUERY_COMMANDS_LITERAL;\n}\nexports.isKnownQueryCommand = isKnownQueryCommand;\nfunction isComparisonCommand(object) {\n    return isQueryCommand(object);\n}\nexports.isComparisonCommand = isComparisonCommand;\nexports.default = QueryCommand;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../helper/symbol\");\nconst query_1 = require(\"./query\");\nexports.AND = 'and';\nexports.OR = 'or';\nexports.NOT = 'not';\nexports.NOR = 'nor';\nvar LOGIC_COMMANDS_LITERAL;\n(function (LOGIC_COMMANDS_LITERAL) {\n    LOGIC_COMMANDS_LITERAL[\"AND\"] = \"and\";\n    LOGIC_COMMANDS_LITERAL[\"OR\"] = \"or\";\n    LOGIC_COMMANDS_LITERAL[\"NOT\"] = \"not\";\n    LOGIC_COMMANDS_LITERAL[\"NOR\"] = \"nor\";\n})(LOGIC_COMMANDS_LITERAL = exports.LOGIC_COMMANDS_LITERAL || (exports.LOGIC_COMMANDS_LITERAL = {}));\nclass LogicCommand {\n    constructor(operator, operands, fieldName) {\n        this._internalType = symbol_1.SYMBOL_LOGIC_COMMAND;\n        Object.defineProperties(this, {\n            _internalType: {\n                enumerable: false,\n                configurable: false,\n            },\n        });\n        this.operator = operator;\n        this.operands = operands;\n        this.fieldName = fieldName || symbol_1.SYMBOL_UNSET_FIELD_NAME;\n        if (this.fieldName !== symbol_1.SYMBOL_UNSET_FIELD_NAME) {\n            operands = operands.slice();\n            this.operands = operands;\n            for (let i = 0, len = operands.length; i < len; i++) {\n                const query = operands[i];\n                if (isLogicCommand(query) || query_1.isQueryCommand(query)) {\n                    operands[i] = query._setFieldName(this.fieldName);\n                }\n            }\n        }\n    }\n    _setFieldName(fieldName) {\n        const operands = this.operands.map(operand => {\n            if (operand instanceof LogicCommand) {\n                return operand._setFieldName(fieldName);\n            }\n            else {\n                return operand;\n            }\n        });\n        const command = new LogicCommand(this.operator, operands, fieldName);\n        return command;\n    }\n    and(...__expressions__) {\n        const expressions = Array.isArray(arguments[0]) ? arguments[0] : Array.from(arguments);\n        expressions.unshift(this);\n        return new LogicCommand(LOGIC_COMMANDS_LITERAL.AND, expressions, this.fieldName);\n    }\n    or(...__expressions__) {\n        const expressions = Array.isArray(arguments[0]) ? arguments[0] : Array.from(arguments);\n        expressions.unshift(this);\n        return new LogicCommand(LOGIC_COMMANDS_LITERAL.OR, expressions, this.fieldName);\n    }\n}\nexports.LogicCommand = LogicCommand;\nfunction isLogicCommand(object) {\n    return object && (object instanceof LogicCommand) && (object._internalType === symbol_1.SYMBOL_LOGIC_COMMAND);\n}\nexports.isLogicCommand = isLogicCommand;\nfunction isKnownLogicCommand(object) {\n    return isLogicCommand && (object.operator.toUpperCase() in LOGIC_COMMANDS_LITERAL);\n}\nexports.isKnownLogicCommand = isKnownLogicCommand;\nexports.default = LogicCommand;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst type_1 = require(\"../utils/type\");\nconst datatype_1 = require(\"./datatype\");\nfunction flatten(query, shouldPreserverObject, parents, visited) {\n    const cloned = Object.assign({}, query);\n    for (const key in query) {\n        if (/^\\$/.test(key))\n            continue;\n        const value = query[key];\n        if (!value)\n            continue;\n        if (type_1.isObject(value) && !shouldPreserverObject(value)) {\n            if (visited.indexOf(value) > -1) {\n                throw new Error('Cannot convert circular structure to JSON');\n            }\n            const newParents = [\n                ...parents,\n                key,\n            ];\n            const newVisited = [\n                ...visited,\n                value,\n            ];\n            const flattenedChild = flatten(value, shouldPreserverObject, newParents, newVisited);\n            cloned[key] = flattenedChild;\n            let hasKeyNotCombined = false;\n            for (const childKey in flattenedChild) {\n                if (!/^\\$/.test(childKey)) {\n                    cloned[`${key}.${childKey}`] = flattenedChild[childKey];\n                    delete cloned[key][childKey];\n                }\n                else {\n                    hasKeyNotCombined = true;\n                }\n            }\n            if (!hasKeyNotCombined) {\n                delete cloned[key];\n            }\n        }\n    }\n    return cloned;\n}\nfunction flattenQueryObject(query) {\n    return flatten(query, isConversionRequired, [], [query]);\n}\nexports.flattenQueryObject = flattenQueryObject;\nfunction flattenObject(object) {\n    return flatten(object, (_) => false, [], [object]);\n}\nexports.flattenObject = flattenObject;\nfunction mergeConditionAfterEncode(query, condition, key) {\n    if (!condition[key]) {\n        delete query[key];\n    }\n    for (const conditionKey in condition) {\n        if (query[conditionKey]) {\n            if (type_1.isArray(query[conditionKey])) {\n                query[conditionKey].push(condition[conditionKey]);\n            }\n            else if (type_1.isObject(query[conditionKey])) {\n                if (type_1.isObject(condition[conditionKey])) {\n                    Object.assign(query[conditionKey], condition[conditionKey]);\n                }\n                else {\n                    console.warn(`unmergable condition, query is object but condition is ${type_1.getType(condition)}, can only overwrite`, condition, key);\n                    query[conditionKey] = condition[conditionKey];\n                }\n            }\n            else {\n                console.warn(`to-merge query is of type ${type_1.getType(query)}, can only overwrite`, query, condition, key);\n                query[conditionKey] = condition[conditionKey];\n            }\n        }\n        else {\n            query[conditionKey] = condition[conditionKey];\n        }\n    }\n}\nexports.mergeConditionAfterEncode = mergeConditionAfterEncode;\nfunction isConversionRequired(val) {\n    return type_1.isInternalObject(val) || type_1.isDate(val) || type_1.isRegExp(val);\n}\nexports.isConversionRequired = isConversionRequired;\nfunction encodeInternalDataType(val) {\n    return datatype_1.serialize(val);\n}\nexports.encodeInternalDataType = encodeInternalDataType;\nfunction decodeInternalDataType(object) {\n    return datatype_1.deserialize(object);\n}\nexports.decodeInternalDataType = decodeInternalDataType;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../helper/symbol\");\nconst type_1 = require(\"../utils/type\");\nconst geo_1 = require(\"../geo\");\nconst serverDate_1 = require(\"../serverDate\");\nfunction serialize(val) {\n    return serializeHelper(val, [val]);\n}\nexports.serialize = serialize;\nfunction serializeHelper(val, visited) {\n    if (type_1.isInternalObject(val)) {\n        switch (val._internalType) {\n            case symbol_1.SYMBOL_GEO_POINT: {\n                return val.toJSON();\n            }\n            case symbol_1.SYMBOL_SERVER_DATE: {\n                return val.parse();\n            }\n            case symbol_1.SYMBOL_REGEXP: {\n                return val.parse();\n            }\n            default: {\n                return val.toJSON ? val.toJSON() : val;\n            }\n        }\n    }\n    else if (type_1.isDate(val)) {\n        return {\n            $date: +val,\n        };\n    }\n    else if (type_1.isRegExp(val)) {\n        return {\n            $regex: val.source,\n            $options: val.flags,\n        };\n    }\n    else if (type_1.isArray(val)) {\n        return val.map(item => {\n            if (visited.indexOf(item) > -1) {\n                throw new Error('Cannot convert circular structure to JSON');\n            }\n            return serializeHelper(item, [\n                ...visited,\n                item,\n            ]);\n        });\n    }\n    else if (type_1.isObject(val)) {\n        const ret = Object.assign({}, val);\n        for (const key in ret) {\n            if (visited.indexOf(ret[key]) > -1) {\n                throw new Error('Cannot convert circular structure to JSON');\n            }\n            ret[key] = serializeHelper(ret[key], [\n                ...visited,\n                ret[key],\n            ]);\n        }\n        return ret;\n    }\n    else {\n        return val;\n    }\n}\nfunction deserialize(object) {\n    const ret = Object.assign({}, object);\n    for (const key in ret) {\n        switch (key) {\n            case '$date': {\n                switch (type_1.getType(ret[key])) {\n                    case 'number': {\n                        return new Date(ret[key]);\n                    }\n                    case 'object': {\n                        return new serverDate_1.ServerDate(ret[key]);\n                    }\n                }\n                break;\n            }\n            case 'type': {\n                switch (ret.type) {\n                    case 'Point': {\n                        if (type_1.isArray(ret.coordinates) && type_1.isNumber(ret.coordinates[0]) && type_1.isNumber(ret.coordinates[1])) {\n                            return new geo_1.Point(ret.coordinates[0], ret.coordinates[1]);\n                        }\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    return object;\n}\nexports.deserialize = deserialize;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"./lib/util\");\nconst db_1 = require(\"./db\");\nconst validate_1 = require(\"./validate\");\nconst util_2 = require(\"./util\");\nconst query_1 = require(\"./serializer/query\");\nconst update_1 = require(\"./serializer/update\");\nclass Query {\n    constructor(db, coll, fieldFilters, fieldOrders, queryOptions) {\n        this._db = db;\n        this._coll = coll;\n        this._fieldFilters = fieldFilters;\n        this._fieldOrders = fieldOrders || [];\n        this._queryOptions = queryOptions || {};\n        this._request = new db_1.Db.reqClass(this._db.config);\n    }\n    get(callback) {\n        callback = callback || util_1.createPromiseCallback();\n        let newOder = [];\n        if (this._fieldOrders) {\n            this._fieldOrders.forEach(order => {\n                newOder.push(order);\n            });\n        }\n        let param = {\n            collectionName: this._coll\n        };\n        if (this._fieldFilters) {\n            param.query = this._fieldFilters;\n        }\n        if (newOder.length > 0) {\n            param.order = newOder;\n        }\n        if (this._queryOptions.offset) {\n            param.offset = this._queryOptions.offset;\n        }\n        if (this._queryOptions.limit) {\n            param.limit =\n                this._queryOptions.limit < 100 ? this._queryOptions.limit : 100;\n        }\n        else {\n            param.limit = 100;\n        }\n        if (this._queryOptions.projection) {\n            param.projection = this._queryOptions.projection;\n        }\n        this._request.send('database.queryDocument', param).then(res => {\n            if (res.code) {\n                callback(0, res);\n            }\n            else {\n                const documents = util_2.Util.formatResDocumentData(res.data.list);\n                const result = {\n                    data: documents,\n                    requestId: res.requestId\n                };\n                if (res.TotalCount)\n                    result.total = res.TotalCount;\n                if (res.Limit)\n                    result.limit = res.Limit;\n                if (res.Offset)\n                    result.offset = res.Offset;\n                callback(0, result);\n            }\n        }).catch((err) => {\n            callback(err);\n        });\n        return callback.promise;\n    }\n    count(callback) {\n        callback = callback || util_1.createPromiseCallback();\n        let param = {\n            collectionName: this._coll\n        };\n        if (this._fieldFilters) {\n            param.query = this._fieldFilters;\n        }\n        this._request.send('database.countDocument', param).then(res => {\n            if (res.code) {\n                callback(0, res);\n            }\n            else {\n                callback(0, {\n                    requestId: res.requestId,\n                    total: res.data.total\n                });\n            }\n        });\n        return callback.promise;\n    }\n    where(query) {\n        return new Query(this._db, this._coll, query_1.QuerySerializer.encode(query), this._fieldOrders, this._queryOptions);\n    }\n    orderBy(fieldPath, directionStr) {\n        validate_1.Validate.isFieldPath(fieldPath);\n        validate_1.Validate.isFieldOrder(directionStr);\n        const newOrder = {\n            field: fieldPath,\n            direction: directionStr\n        };\n        const combinedOrders = this._fieldOrders.concat(newOrder);\n        return new Query(this._db, this._coll, this._fieldFilters, combinedOrders, this._queryOptions);\n    }\n    limit(limit) {\n        validate_1.Validate.isInteger('limit', limit);\n        let option = Object.assign({}, this._queryOptions);\n        option.limit = limit;\n        return new Query(this._db, this._coll, this._fieldFilters, this._fieldOrders, option);\n    }\n    skip(offset) {\n        validate_1.Validate.isInteger('offset', offset);\n        let option = Object.assign({}, this._queryOptions);\n        option.offset = offset;\n        return new Query(this._db, this._coll, this._fieldFilters, this._fieldOrders, option);\n    }\n    update(data, callback) {\n        callback = callback || util_1.createPromiseCallback();\n        if (!data || typeof data !== 'object') {\n            return Promise.resolve({\n                code: 'INVALID_PARAM',\n                message: '参数必需是非空对象'\n            });\n        }\n        if (data.hasOwnProperty('_id')) {\n            return Promise.resolve({\n                code: 'INVALID_PARAM',\n                message: '不能更新_id的值'\n            });\n        }\n        let param = {\n            collectionName: this._coll,\n            query: this._fieldFilters,\n            multi: true,\n            merge: true,\n            upsert: false,\n            data: update_1.UpdateSerializer.encode(data)\n        };\n        this._request.send('database.updateDocument', param).then(res => {\n            if (res.code) {\n                callback(0, res);\n            }\n            else {\n                callback(0, {\n                    requestId: res.requestId,\n                    updated: res.data.updated,\n                    upsertId: res.data.upsert_id\n                });\n            }\n        });\n        return callback.promise;\n    }\n    field(projection) {\n        for (let k in projection) {\n            if (projection[k]) {\n                projection[k] = 1;\n            }\n            else {\n                projection[k] = 0;\n            }\n        }\n        let option = Object.assign({}, this._queryOptions);\n        option.projection = projection;\n        return new Query(this._db, this._coll, this._fieldFilters, this._fieldOrders, option);\n    }\n    remove(callback) {\n        callback = callback || util_1.createPromiseCallback();\n        if (Object.keys(this._queryOptions).length > 0) {\n            console.warn('`offset`, `limit` and `projection` are not supported in remove() operation');\n        }\n        if (this._fieldOrders.length > 0) {\n            console.warn('`orderBy` is not supported in remove() operation');\n        }\n        const param = {\n            collectionName: this._coll,\n            query: query_1.QuerySerializer.encode(this._fieldFilters),\n            multi: true\n        };\n        this._request.send('database.deleteDocument', param).then(res => {\n            if (res.code) {\n                callback(0, res);\n            }\n            else {\n                callback(0, {\n                    requestId: res.requestId,\n                    deleted: res.data.deleted\n                });\n            }\n        });\n        return callback.promise;\n    }\n}\nexports.Query = Query;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst query_1 = require(\"../commands/query\");\nconst logic_1 = require(\"../commands/logic\");\nconst symbol_1 = require(\"../helper/symbol\");\nconst type_1 = require(\"../utils/type\");\nconst operator_map_1 = require(\"../operator-map\");\nconst common_1 = require(\"./common\");\nclass QuerySerializer {\n    constructor() {\n    }\n    static encode(query) {\n        const encoder = new QueryEncoder();\n        return encoder.encodeQuery(query);\n    }\n}\nexports.QuerySerializer = QuerySerializer;\nclass QueryEncoder {\n    encodeQuery(query, key) {\n        if (common_1.isConversionRequired(query)) {\n            if (logic_1.isLogicCommand(query)) {\n                return this.encodeLogicCommand(query);\n            }\n            else if (query_1.isQueryCommand(query)) {\n                return this.encodeQueryCommand(query);\n            }\n            else {\n                return { [key]: this.encodeQueryObject(query) };\n            }\n        }\n        else {\n            if (type_1.isObject(query)) {\n                return this.encodeQueryObject(query);\n            }\n            else {\n                return query;\n            }\n        }\n    }\n    encodeLogicCommand(query) {\n        switch (query.operator) {\n            case logic_1.LOGIC_COMMANDS_LITERAL.AND:\n            case logic_1.LOGIC_COMMANDS_LITERAL.OR: {\n                const $op = operator_map_1.operatorToString(query.operator);\n                const subqueries = query.operands.map((oprand) => this.encodeQuery(oprand, query.fieldName));\n                return {\n                    [$op]: subqueries,\n                };\n            }\n            default: {\n                const $op = operator_map_1.operatorToString(query.operator);\n                if (query.operands.length === 1) {\n                    const subquery = this.encodeQuery(query.operands[0]);\n                    return {\n                        [$op]: subquery,\n                    };\n                }\n                else {\n                    const subqueries = query.operands.map(this.encodeQuery.bind(this));\n                    return {\n                        [$op]: subqueries,\n                    };\n                }\n            }\n        }\n    }\n    encodeQueryCommand(query) {\n        if (query_1.isComparisonCommand(query)) {\n            return this.encodeComparisonCommand(query);\n        }\n        else {\n            return this.encodeComparisonCommand(query);\n        }\n    }\n    encodeComparisonCommand(query) {\n        if (query.fieldName === symbol_1.SYMBOL_UNSET_FIELD_NAME) {\n            throw new Error('Cannot encode a comparison command with unset field name');\n        }\n        const $op = operator_map_1.operatorToString(query.operator);\n        switch (query.operator) {\n            case query_1.QUERY_COMMANDS_LITERAL.EQ:\n            case query_1.QUERY_COMMANDS_LITERAL.NEQ:\n            case query_1.QUERY_COMMANDS_LITERAL.LT:\n            case query_1.QUERY_COMMANDS_LITERAL.LTE:\n            case query_1.QUERY_COMMANDS_LITERAL.GT:\n            case query_1.QUERY_COMMANDS_LITERAL.GTE: {\n                return {\n                    [query.fieldName]: {\n                        [$op]: common_1.encodeInternalDataType(query.operands[0]),\n                    },\n                };\n            }\n            case query_1.QUERY_COMMANDS_LITERAL.IN:\n            case query_1.QUERY_COMMANDS_LITERAL.NIN: {\n                return {\n                    [query.fieldName]: {\n                        [$op]: common_1.encodeInternalDataType(query.operands),\n                    },\n                };\n            }\n            case query_1.QUERY_COMMANDS_LITERAL.GEO_NEAR: {\n                const options = query.operands[0];\n                return {\n                    [query.fieldName]: {\n                        $nearSphere: {\n                            $geometry: options.geometry.toJSON(),\n                            $maxDistance: options.maxDistance,\n                            $minDistance: options.minDistance\n                        }\n                    }\n                };\n            }\n            case query_1.QUERY_COMMANDS_LITERAL.GEO_WITHIN: {\n                const options = query.operands[0];\n                return {\n                    [query.fieldName]: {\n                        $geoWithin: {\n                            $geometry: options.geometry.toJSON()\n                        }\n                    }\n                };\n            }\n            case query_1.QUERY_COMMANDS_LITERAL.GEO_INTERSECTS: {\n                const options = query.operands[0];\n                return {\n                    [query.fieldName]: {\n                        $geoIntersects: {\n                            $geometry: options.geometry.toJSON()\n                        }\n                    }\n                };\n            }\n            default: {\n                return {\n                    [query.fieldName]: {\n                        [$op]: common_1.encodeInternalDataType(query.operands[0]),\n                    },\n                };\n            }\n        }\n    }\n    encodeQueryObject(query) {\n        const flattened = common_1.flattenQueryObject(query);\n        for (const key in flattened) {\n            const val = flattened[key];\n            if (logic_1.isLogicCommand(val)) {\n                flattened[key] = val._setFieldName(key);\n                const condition = this.encodeLogicCommand(flattened[key]);\n                this.mergeConditionAfterEncode(flattened, condition, key);\n            }\n            else if (query_1.isComparisonCommand(val)) {\n                flattened[key] = val._setFieldName(key);\n                const condition = this.encodeComparisonCommand(flattened[key]);\n                this.mergeConditionAfterEncode(flattened, condition, key);\n            }\n            else if (common_1.isConversionRequired(val)) {\n                flattened[key] = common_1.encodeInternalDataType(val);\n            }\n        }\n        return flattened;\n    }\n    mergeConditionAfterEncode(query, condition, key) {\n        if (!condition[key]) {\n            delete query[key];\n        }\n        for (const conditionKey in condition) {\n            if (query[conditionKey]) {\n                if (type_1.isArray(query[conditionKey])) {\n                    query[conditionKey].push(condition[conditionKey]);\n                }\n                else if (type_1.isObject(query[conditionKey])) {\n                    if (type_1.isObject(condition[conditionKey])) {\n                        Object.assign(query, condition);\n                    }\n                    else {\n                        console.warn(`unmergable condition, query is object but condition is ${type_1.getType(condition)}, can only overwrite`, condition, key);\n                        query[conditionKey] = condition[conditionKey];\n                    }\n                }\n                else {\n                    console.warn(`to-merge query is of type ${type_1.getType(query)}, can only overwrite`, query, condition, key);\n                    query[conditionKey] = condition[conditionKey];\n                }\n            }\n            else {\n                query[conditionKey] = condition[conditionKey];\n            }\n        }\n    }\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst db_1 = require(\"./db\");\nconst bson_1 = require(\"bson\");\nclass Aggregation {\n    constructor(db, collectionName) {\n        this._db = db;\n        this._request = new db_1.Db.reqClass(this._db.config);\n        this._stages = [];\n        this._collectionName = collectionName;\n    }\n    async end() {\n        const result = await this._request.send('database.aggregate', {\n            collectionName: this._collectionName,\n            stages: this._stages\n        });\n        if (result && result.data && result.data.list) {\n            return {\n                requestId: result.requestId,\n                data: JSON.parse(result.data.list).map(bson_1.EJSON.parse)\n            };\n        }\n        return result;\n    }\n    unwrap() {\n        return this._stages;\n    }\n}\nexports.default = Aggregation;\nconst pipelineStages = [\n    'addFields',\n    'bucket',\n    'bucketAuto',\n    'count',\n    'geoNear',\n    'group',\n    'limit',\n    'match',\n    'project',\n    'lookup',\n    'replaceRoot',\n    'sample',\n    'skip',\n    'sort',\n    'sortByCount',\n    'unwind'\n];\npipelineStages.forEach(stage => {\n    Aggregation.prototype[stage] = function (param) {\n        this._stages.push({\n            stageKey: `$${stage}`,\n            stageValue: JSON.stringify(param)\n        });\n        return this;\n    };\n});\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst query_1 = require(\"./commands/query\");\nconst logic_1 = require(\"./commands/logic\");\nconst update_1 = require(\"./commands/update\");\nconst type_1 = require(\"./utils/type\");\nexports.Command = {\n    eq(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.EQ, [val]);\n    },\n    neq(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.NEQ, [val]);\n    },\n    lt(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.LT, [val]);\n    },\n    lte(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.LTE, [val]);\n    },\n    gt(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.GT, [val]);\n    },\n    gte(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.GTE, [val]);\n    },\n    in(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.IN, val);\n    },\n    nin(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.NIN, val);\n    },\n    geoNear(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.GEO_NEAR, [val]);\n    },\n    geoWithin(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.GEO_WITHIN, [val]);\n    },\n    geoIntersects(val) {\n        return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.GEO_INTERSECTS, [val]);\n    },\n    and(...__expressions__) {\n        const expressions = type_1.isArray(arguments[0]) ? arguments[0] : Array.from(arguments);\n        return new logic_1.LogicCommand(logic_1.LOGIC_COMMANDS_LITERAL.AND, expressions);\n    },\n    or(...__expressions__) {\n        const expressions = type_1.isArray(arguments[0]) ? arguments[0] : Array.from(arguments);\n        return new logic_1.LogicCommand(logic_1.LOGIC_COMMANDS_LITERAL.OR, expressions);\n    },\n    set(val) {\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.SET, [val]);\n    },\n    remove() {\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.REMOVE, []);\n    },\n    inc(val) {\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.INC, [val]);\n    },\n    mul(val) {\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.MUL, [val]);\n    },\n    push(...__values__) {\n        const values = type_1.isArray(arguments[0]) ? arguments[0] : Array.from(arguments);\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.PUSH, values);\n    },\n    pop() {\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.POP, []);\n    },\n    shift() {\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.SHIFT, []);\n    },\n    unshift(...__values__) {\n        const values = type_1.isArray(arguments[0]) ? arguments[0] : Array.from(arguments);\n        return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.UNSHIFT, values);\n    },\n    aggregate: {}\n};\nconst pipelineOperators = [\n    'abs',\n    'add',\n    'ceil',\n    'divide',\n    'exp',\n    'floor',\n    'ln',\n    'log',\n    'log10',\n    'mod',\n    'multiply',\n    'pow',\n    'sqrt',\n    'subtract',\n    'trunc',\n    'arrayElemAt',\n    'arrayToObject',\n    'concatArrays',\n    'filter',\n    'in',\n    'indexOfArray',\n    'isArray',\n    'map',\n    'objectToArray',\n    'range',\n    'reduce',\n    'reverseArray',\n    'size',\n    'slice',\n    'zip',\n    'and',\n    'not',\n    'or',\n    'cmp',\n    'eq',\n    'gt',\n    'gte',\n    'lt',\n    'lte',\n    'ne',\n    'cond',\n    'ifNull',\n    'switch',\n    'dayOfWeek',\n    'dateFromParts',\n    'dateFromString',\n    'dayOfMonth',\n    'dayOfWeek',\n    'dayOfYear',\n    'isoDayOfWeek',\n    'isoWeek',\n    'isoWeekYear',\n    'millisecond',\n    'minute',\n    'month',\n    'second',\n    'hour',\n    'week',\n    'year',\n    'literal',\n    'mergeObjects',\n    'objectToArray',\n    'allElementsTrue',\n    'anyElementTrue',\n    'setDifference',\n    'setEquals',\n    'setIntersection',\n    'setIsSubset',\n    'setUnion',\n    'concat',\n    'dateToString',\n    'indexOfBytes',\n    'indexOfCP',\n    'split',\n    'strLenBytes',\n    'strLenCP',\n    'strcasecmp',\n    'substr',\n    'substrBytes',\n    'substrCP',\n    'toLower',\n    'toUpper',\n    'meta',\n    'addToSet',\n    'avg',\n    'first',\n    'last',\n    'max',\n    'min',\n    'push',\n    'stdDevPop',\n    'stdDevSamp',\n    'sum',\n    'let'\n];\npipelineOperators.forEach(op => {\n    let apiName = op;\n    if (op === 'ne') {\n        apiName = 'neq';\n    }\n    exports.Command.aggregate[apiName] = function (param) {\n        return {\n            [`$${op}`]: param\n        };\n    };\n});\nexports.default = exports.Command;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbol_1 = require(\"../helper/symbol\");\nclass RegExp {\n    constructor({ regexp, options }) {\n        if (!regexp) {\n            throw new TypeError('regexp must be a string');\n        }\n        this.$regex = regexp;\n        this.$options = options;\n    }\n    parse() {\n        return {\n            $regex: this.$regex,\n            $options: this.$options\n        };\n    }\n    get _internalType() {\n        return symbol_1.SYMBOL_REGEXP;\n    }\n}\nexports.RegExp = RegExp;\nfunction RegExpConstructor(param) {\n    return new RegExp(param);\n}\nexports.RegExpConstructor = RegExpConstructor;\n"]}